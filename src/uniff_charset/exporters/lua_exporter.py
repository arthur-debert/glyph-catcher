"""
Lua exporter implementation.
"""
import logging
from typing import Optional

from ..validator import validate_lua_file
from .base import BaseExporter

logger = logging.getLogger('uniff')



class LuaExporter(BaseExporter):
    """
    Exporter for Lua format.
    """

    @property
    def format_type(self) -> str:
        """
        Get the format type that this exporter handles.

        Returns:
            The format type ('lua')
        """
        return "lua"

    @property
    def extension(self) -> str:
        """
        Get the file extension for this format.

        Returns:
            The file extension ('.lua')
        """
        return ".lua"

    def write(
        self,
        unicode_data: dict[str, dict[str, str]],
        aliases_data: dict[str, list[str]],
        output_filename: str,
    ) -> bool:
        """
        Write Unicode data as a Lua module.

        Args:
            unicode_data: Dictionary mapping code points to character information
            aliases_data: Dictionary mapping code points to lists of aliases
            output_filename: Path to the output file

        Returns:
            True if the write was successful, False otherwise
        """
        if not unicode_data:
            logger.debug("No Unicode data to write. Aborting Lua module creation.")
            return False

        logger.debug(f"Creating Lua module for {len(unicode_data)} characters")

        try:
            with open(output_filename, "w", encoding="utf-8") as f:
                f.write("-- Auto-generated unicode data module\n")
                f.write("-- Generated by uniff-gen\n")
                f.write("return {\n")

                for code_point_hex, data in unicode_data.items():
                    aliases = aliases_data.get(code_point_hex, [])
                    # Handle special characters for Lua
                    char = data["char_obj"]
                    logger.debug(f"Processing character U+{code_point_hex}: {data['name']}")
                    if char == "\n":
                        char = "\\n"
                    elif char == "\r":
                        char = "\\r"
                    elif char == "\t":
                        char = "\\t"
                    elif char == '"':
                        char = '\\"'
                    elif char == "\\":
                        char = "\\\\"
                    elif ord(char) < 32:  # Other control characters
                        char = f"\\{ord(char):03d}"

                    # Helper function to properly escape Lua strings
                    def escape_lua_string(s):
                        # First escape backslashes
                        s = s.replace("\\", "\\\\")
                        # Then escape other special characters
                        s = s.replace('"', '\\"')
                        s = s.replace("\n", "\\n")
                        s = s.replace("\r", "\\r")
                        s = s.replace("\t", "\\t")
                        # Replace any other control characters
                        result = ""
                        for c in s:
                            if ord(c) < 32 and c not in "\n\r\t":
                                result += f"\\{ord(c):03d}"
                            else:
                                result += c
                        return result

                    # Escape special characters in all string fields
                    name = escape_lua_string(data["name"])
                    category = escape_lua_string(data["category"])
                    block = escape_lua_string(data.get("block", "Unknown Block"))

                    f.write("  {\n")
                    f.write(f'    code_point = "U+{code_point_hex}",\n')
                    f.write(f'    character = "{char}",\n')
                    f.write(f'    name = "{name}",\n')
                    f.write(f'    category = "{category}",\n')
                    f.write(f'    block = "{block}",\n')

                    # Write aliases as a Lua table
                    if aliases:
                        f.write("    aliases = {\n")
                        for alias in aliases:
                            # Use the same escaping function for aliases
                            escaped_alias = escape_lua_string(alias)
                            f.write(f'      "{escaped_alias}",\n')
                        f.write("    },\n")
                    else:
                        f.write("    aliases = {},\n")

                    f.write("  },\n")

                f.write("}\n")
            logger.debug(f"Successfully wrote Lua module to {output_filename}")
            return True
        except Exception as e:
            logger.debug(f"Error writing Lua module: {e}")
            return False

    def verify(self, file_path: str) -> tuple[bool, Optional[str]]:
        """
        Verify that a file is valid for this format.

        Args:
            file_path: Path to the file to verify

        Returns:
            A tuple of (is_valid, error_message)
        """
        is_valid, error = validate_lua_file(file_path)
        if not is_valid:
            logger.debug(f"Lua validation failed: {error}")
        else:
            logger.debug("Lua validation successful")
        return is_valid, error
